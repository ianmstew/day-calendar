<!DOCTYPE html>
<!-- Note: Under normal circumstances, assets would be concatenated and minified
     by a build step. LESS/SASS/Styl for CSS, RequireJS/Browserify/Webpack for JS.
     To adhere to challenge requirements, this approach is purely static, using
     traditional Javascript modules, namespaces, and limited browser globals. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Day Calendar</title>
  <link rel="stylesheet" href="calendar/vendor/css/normalize.css">
  <link rel="stylesheet" href="calendar/css/global.css">
  <link rel="stylesheet" href="calendar/css/day.css">
  <link rel="stylesheet" href="calendar/css/event.css">
</head>
<body>
  <!-- Target render region for widget; see index.js -->
  <main id="calendar-region">
  </main>

  <!-- Prefer templates to reside in view folder, e.g., views/entry/entry.view.tpl,
       except that requires an async text loader like require.js or a build step.
       Both are too heavy for this demo; hence, templates are inlined below.
       They are, however, compiled only once - at script load time. -->

  <!-- Day template -->
  <script id="day-view" type="text/html">
    <div class="ruler-container js-ruler"></div>
    <div class="events-container js-events"></div>
  </script>

  <!-- Entry template -->
  <script id="event-view" type="text/html">
    <div class="event-inner">
      <div class="event-title"><%- title %></div>
      <div class="event-location"><%- location %></div>
    </div>
  </script>

  <!-- Ruler template -->
  <script id="ruler-view" type="text/html">
    <% _.each(times, function (time) { %>
      <div class="time <% if (time.majorTick) { %>time-major<% } else { %>time-minor<% } %>"
           style="height: <%- tickHeight %>">
        <span class="time-string"><%- time.timeStr %></span>
        <span class="time-am-pm"><%- time.amPm %></span>
      </div>
    <% }); %>
  </script>

  <!-- While Backbone is sufficient for this small demo, were the app to grow any
       larger an additional framework like Backbone.Marionette would be beneficial.
       In fact, this widget's view classes have a good bit of boilerplate that could
       be avoided with the addition of Backbone.Marionette. I chose Backbone to
       demonstrate my grasp of the fundamental issues surrounding view management. -->

  <!-- Libraries -->
  <script src="calendar/vendor/js/jquery.js"></script>
  <script src="calendar/vendor/js/underscore.js"></script>
  <script src="calendar/vendor/js/backbone.js"></script>

  <!-- Custom classes -->
  <script src="calendar/classes/backbone.widget.js"></script>
  <script src="calendar/classes/backbone.presenter.js"></script>

  <!-- Widget -->
  <script src="calendar/calendar.js"></script>
  <script src="calendar/presenters/day.presenter.js"></script>
  <script src="calendar/entities/ruler.model.js"></script>
  <script src="calendar/entities/event.model.js"></script>
  <script src="calendar/entities/events.collection.js"></script>
  <script src="calendar/views/day.view.js"></script>
  <script src="calendar/views/ruler.view.js"></script>
  <script src="calendar/views/events.view.js"></script>
  <script src="calendar/views/event.view.js"></script>
  <script src="calendar/lib/util/time.js"></script>
  <script src="calendar/lib/sort/sorter.js"></script>
  <script src="calendar/lib/sort/group.js"></script>
  <script src="calendar/lib/sort/groups.js"></script>

  <!-- Facebook code challenge driver -->
  <script src="index.js"></script>

  <!-- Startup demo -->
  <script>
    var howMany = 7;
    var events = [];
    var start;
    var end;
    var height;

    while (howMany--) {
      height = (Math.random() * 0.25 + 0.05) * 720;
      start = parseInt(Math.random() * (720 - height));
      end = start + height;
      events.push({ start: start, end: end });
    }

    layOutDay(events);
  </script>
</body>
</html>